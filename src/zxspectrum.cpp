// ZX-Spectrum-specific stuff
#include "zxspectrum.h"

namespace zx {

const uint8_t BASin48Vars[] = {
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x23, 0x05, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x06, 0x00, 0x0b, 0x00, 0x01, 0x00, 0x01, 0x00,
        0x06, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x3c, 0x40, 0x00, 0xff, 0xc0, 0x01, 0x54, 0xff, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xfe, 0xff, 0x01, 0x38, 0x00, 0x00, 0xcb, 0x5c, 0x00,
        0x00, 0xb6, 0x5c, 0xb6, 0x5c, 0xcb, 0x5c, 0xdb, 0x5c, 0xca, 0x5c, 0xcc, 0x5c,
        0xd4, 0x5c, 0xda, 0x5c, 0xcf, 0x00, 0xdc, 0x5c, 0xdc, 0x5c, 0xdc, 0x5c, 0x2d,
        0x92, 0x5c, 0x10, 0x02, 0x00, 0x00, 0xfe, 0xff, 0x01, 0x00, 0x00, 0x00, 0xb6,
        0x1a, 0x00, 0x00, 0xe5, 0x00, 0x00, 0x58, 0xff, 0x00, 0x00, 0x21, 0x00, 0x5b,
        0x21, 0x17, 0x00, 0x40, 0xe0, 0x50, 0x21, 0x18, 0x21, 0x17, 0x01, 0x38, 0x00,
        0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0xff, 0xff, 0xff,
        0xf4, 0x09, 0xa8, 0x10, 0x4b, 0xf4, 0x09, 0xc4, 0x15, 0x53, 0x81, 0x0f, 0xc4,
        0x15, 0x52, 0xf4, 0x09, 0xc4, 0x15, 0x50, 0x80, 0x80, 0xf9, 0xc0, 0x33, 0x32,
        0x37, 0x36, 0x38, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x80, 0x00, 0x0d, 0x80, 0x00,
        0x00, 0x00, 0x80, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const uint8_t BASin48SP[] = {
        0xb1, 0x33, 0xe0, 0x5c, 0xc2, 0x02, 0x4d, 0x00, 0xdc, 0x5c, 0x00, 0x80, 0x2b,
        0x2d, 0x54, 0x00, 0x2b, 0x2d, 0x2b, 0x2d, 0x65, 0x33, 0x00, 0x00, 0xed, 0x10,
        0x0d, 0x00, 0x09, 0x00, 0x85, 0x1c, 0x10, 0x1c, 0x52, 0x1b, 0x76, 0x1b, 0x03,
        0x13, 0x00, 0x3e, 0x00, 0x3c, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x00, 0x00, 0x7c,
        0x42, 0x7c, 0x42, 0x42, 0x7c, 0x00, 0x00, 0x3c, 0x42, 0x40, 0x40, 0x42, 0x3c,
        0x00, 0x00, 0x78, 0x44, 0x42, 0x42, 0x44, 0x78, 0x00, 0x00, 0x7e, 0x40, 0x7c,
        0x40, 0x40, 0x7e, 0x00, 0x00, 0x7e, 0x40, 0x7c, 0x40, 0x40, 0x40, 0x00, 0x00,
        0x3c, 0x42, 0x40, 0x4e, 0x42, 0x3c, 0x00, 0x00, 0x42, 0x42, 0x7e, 0x42, 0x42,
        0x42, 0x00, 0x00, 0x3e, 0x08, 0x08, 0x08, 0x08, 0x3e, 0x00, 0x00, 0x02, 0x02,
        0x02, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0x00,
        0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7e, 0x00, 0x00, 0x42, 0x66, 0x5a, 0x42,
        0x42, 0x42, 0x00, 0x00, 0x42, 0x62, 0x52, 0x4a, 0x46, 0x42, 0x00, 0x00, 0x3c,
        0x42, 0x42, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x7c, 0x42, 0x42, 0x7c, 0x40, 0x40,
        0x00, 0x00, 0x3c, 0x42, 0x42, 0x52, 0x4a, 0x3c, 0x00, 0x00, 0x7c, 0x42, 0x42,
        0x7c, 0x44, 0x42, 0x00, 0x00, 0x3c, 0x40, 0x3c, 0x02, 0x42, 0x3c, 0x00, 0x00,
        0xfe, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42,
        0x3c, 0x00, 0x00
};

bool initBasicVars(MemModel &M) {
    uint16_t Size = sizeof(BASin48Vars);
    bool R = M.isUnusedBlock(0x5C00, Size);
    M.memCpy(0x5C00, BASin48Vars, Size, true, true);
    return R;
}

bool initScreenAttrs(MemModel &M) {
    uint16_t Start = 0x4000 + 6144;
    uint16_t Size = 768;
    bool R = M.isUnusedBlock(Start, Size);
    M.memSet(Start, 7 * 8, Size, true, true);
    return R;
}

bool initDefaultBasicStack(MemModel &M) {
    uint16_t Size = sizeof(BASin48SP);
    uint16_t Start = (uint16_t) (0x10000 - Size);
    bool R = M.isUnusedBlock(Start, Size);
    if (!R) // Partial stack is no good
        return R;
    M.memCpy(Start, BASin48SP, Size, true, true);
    return R;
}

uint16_t initMinimalBasicStack(MemModel &M, uint16_t Size, uint16_t PushValue) {
    uint16_t stack;
    const uint16_t S = Size; // Minimum stack size to reserve
    auto StackTop = M.findUnusedBlock(0x5e00 - S, S, 0xc000 - (0x5e00 - S));
    if (StackTop) {
        stack = *StackTop + S;
        stack--;
        M.writeWord(0x5CB2, stack, true, false); // RAMTOP
        stack--;
        M.writeWord(stack, 0x003e, true,
                    false); // The top location (RAMTOP) is made to hold 0x3E (GO SUB stack end marker)
        stack -= 2; // Step down two locations to find the correct value for ERR_SP
        M.writeWord(0x5C3D, stack, true, false); // ERR_SP
        M.writeWord(stack, 0x1303, true,
                    false); // MAIN_4 entry point in ROM (main execution loop after a line has been interpreted)
        if (PushValue != 0) {
            stack -= 2;
            M.writeWord(stack, PushValue, true, false);
        }
    } else {
        Warning("No space available to initialize BASIC stack below 0xC000"s);
        // At this point we do not care about BASIC/ROM viability,
        // let's just try to find a couple of spare bytes anywhere to point SP to.
        StackTop = M.findUnusedBlock(0x5dff, 2, 0x5e00 - 0x4000, true);
        if (!StackTop) {
            // As a last resort try to find spare space in the paged memory
            StackTop = M.findUnusedBlock(0xffff, 2, 0x4000, true);
        }
        if (StackTop)
            stack = *StackTop;
        else
            stack = 0x0000;
        if (PushValue != 0 && stack != 0) {
            M.writeWord(stack, PushValue, true, false);
        }
    }
    return stack;
}

bool isBasicVarAreaOverwritten(MemModel &M) {
    return !M.isUnusedBlock(0x5c00, sizeof(BASin48Vars));
}

bool isScreenOverwritten(MemModel &M) {
    return !M.isUnusedBlock(0x4000, 0x1B00);
}

} // end namespace zx